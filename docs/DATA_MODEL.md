# Data Model Documentation

## Database Schema Overview

The Social Media Sentiment Analytics System uses **H2 in-memory database** for development with plans for PostgreSQL production deployment. The schema supports unified cross-platform social media data for Reddit and YouTube.

## Core Entities

### 1. SocialPost Entity

**Table**: `social_posts`

**Purpose**: Central entity representing social media posts across Reddit and YouTube platforms.

#### Current Schema (Based on Your Entity)
```sql
CREATE TABLE social_posts (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    external_id VARCHAR(255) NOT NULL,
    platform VARCHAR(20) NOT NULL,
    title VARCHAR(500) NOT NULL,
    content TEXT,
    author VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    ingested_at TIMESTAMP NOT NULL,
    processed_at TIMESTAMP,
    content_hash VARCHAR(64),
    
    -- Engagement metrics (2025 version - no downvotes)
    upvotes BIGINT DEFAULT 0,           -- Reddit only
    like_count BIGINT DEFAULT 0,        -- YouTube only  
    view_count BIGINT DEFAULT 0,        -- YouTube only
    comment_count BIGINT DEFAULT 0,     -- Both platforms
    share_count BIGINT DEFAULT 0,       -- Both platforms
    engagement_score DOUBLE DEFAULT 0.0, -- Calculated field
    
    -- Platform-specific context
    subreddit VARCHAR(100),             -- Reddit: technology, programming
    video_id VARCHAR(500),              -- YouTube: dQw4w9WgXcQ  
    url VARCHAR(1000),                  -- External URL
    
    -- Constraints
    CONSTRAINT uk_external_platform UNIQUE (external_id, platform)
);
```

#### Indexes (Production Ready)
```sql
CREATE INDEX idx_platform_created ON social_posts (platform, created_at);
CREATE INDEX idx_engagement ON social_posts (engagement_score DESC);
CREATE INDEX idx_subreddit ON social_posts (subreddit);
CREATE INDEX idx_video_id ON social_posts (video_id);
CREATE INDEX idx_author ON social_posts (author);
CREATE UNIQUE INDEX idx_external_platform ON social_posts (external_id, platform);
```

#### Field Mapping by Platform

| Field | Reddit | YouTube | Description |
|-------|--------|---------|-------------|
| `external_id` | Post ID from Reddit | Video ID from YouTube | Unique identifier per platform |
| `title` | Post title | Video title | Both platforms have titles in 2025 |
| `content` | Post selftext | Video description | Required for Reddit, optional for YouTube |
| `author` | Reddit username | Channel name | Content creator identifier |
| `upvotes` | Reddit score | NULL | Reddit engagement metric |
| `like_count` | NULL | YouTube likes | YouTube engagement metric |
| `view_count` | NULL | YouTube views | YouTube-specific metric |
| `subreddit` | r/technology | NULL | Reddit community |
| `video_id` | NULL | YouTube ID | YouTube-specific identifier |

### 2. SentimentData Entity (Ready for Implementation)

**Table**: `sentiment_data`

**Purpose**: Stores sentiment analysis results with confidence metrics.

#### Schema Definition
```sql
CREATE TABLE sentiment_data (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    social_post_id BIGINT NOT NULL,
    sentiment_label VARCHAR(20) NOT NULL,
    sentiment_score DOUBLE NOT NULL,
    confidence DOUBLE NOT NULL,
    processed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Foreign key constraint
    CONSTRAINT fk_sentiment_social_post 
        FOREIGN KEY (social_post_id) REFERENCES social_posts(id),
    
    -- Unique constraint (one sentiment per post)
    CONSTRAINT uk_sentiment_post UNIQUE (social_post_id)
);
```

#### Sentiment Labels (Enum Implementation Ready)
```java
public enum SentimentLabel {
    POSITIVE,   // > 0.6 sentiment score
    NEUTRAL,    // 0.4 to 0.6 sentiment score  
    NEGATIVE,   // < 0.4 sentiment score
    MIXED,      // Complex sentiment patterns
    UNKNOWN     // Analysis failed or uncertain
}
```

## Platform Enum Implementation

```java
public enum Platform {
    REDDIT("REDDIT", "Reddit"),
    YOUTUBE("YOUTUBE", "YouTube");
    
    private final String code;
    private final String displayName;
    
    Platform(String code, String displayName) {
        this.code = code;
        this.displayName = displayName;
    }
    
    // Getters
    public String getCode() { return code; }
    public String getDisplayName() { return displayName; }
}
```

## Data Access Layer

### SocialPostRepository (Implemented Queries)

Based on your existing code, the repository provides these query methods:

```java
public interface SocialPostRepository extends JpaRepository<SocialPost, Long> {
    
    // Duplicate detection (currently implemented)
    boolean existsByExternalIdAndPlatform(String externalId, Platform platform);
    
    // Statistics queries (currently implemented)
    long count();
    
    @Query("SELECT COUNT(s) FROM SocialPost s WHERE s.platform = ?1 AND s.createdAt >= ?2")
    Long countByPlatformSince(Platform platform, LocalDateTime since);
    
    // Platform filtering (ready for implementation)
    List<SocialPost> findByPlatform(Platform platform);
    
    Page<SocialPost> findByPlatformIn(List<Platform> platforms, Pageable pageable);
    
    // Content search (ready for implementation)
    @Query("SELECT s FROM SocialPost s WHERE " +
           "(LOWER(s.title) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           " LOWER(s.content) LIKE LOWER(CONCAT('%', :keyword, '%'))) " +
           "ORDER BY s.engagementScore DESC")
    List<SocialPost> findByContentContaining(@Param("keyword") String keyword, Pageable pageable);
    
    // Reddit-specific queries (ready for implementation)
    List<SocialPost> findBySubreddit(String subreddit);
    
    @Query("SELECT s.subreddit, COUNT(s), AVG(s.engagementScore) " +
           "FROM SocialPost s WHERE s.platform = 'REDDIT' AND s.subreddit IS NOT NULL " +
           "GROUP BY s.subreddit ORDER BY AVG(s.engagementScore) DESC")
    List<Object[]> getSubredditStats();
    
    // YouTube-specific queries (ready for implementation)
    List<SocialPost> findByVideoId(String videoId);
    
    @Query("SELECT s.author, COUNT(s), AVG(s.engagementScore) " +
           "FROM SocialPost s WHERE s.platform = 'YOUTUBE' " +
           "GROUP BY s.author ORDER BY AVG(s.engagementScore) DESC")
    List<Object[]> getChannelStats();
}
```

### SentimentDataRepository (Ready for Implementation)

```java
public interface SentimentDataRepository extends JpaRepository<SentimentData, Long> {
    
    // Basic sentiment queries
    List<SentimentData> findBySocialPostId(Long socialPostId);
    
    // Platform-based sentiment analysis
    @Query("SELECT sp.platform, AVG(sd.sentimentScore), COUNT(sd) " +
           "FROM SentimentData sd JOIN sd.socialPost sp " +
           "WHERE sd.processedAt >= :since " +
           "GROUP BY sp.platform")
    List<Object[]> getPlatformSentimentStats(@Param("since") LocalDateTime since);
    
    // Confidence filtering
    List<SentimentData> findByConfidenceGreaterThan(Double minConfidence);
}
```

## Engagement Score Algorithms

### Current Implementation

**Reddit Engagement Formula** (from your code):
```java
private double calculateRedditEngagement() {
    long upvotes = this.upvotes != null ? this.upvotes : 0;
    long comments = this.commentCount != null ? this.commentCount : 0;
    
    // Comments weighted higher than upvotes (encourages discussion)
    double score = upvotes + (comments * 2.5);
    
    // Logarithmic scaling prevents extremely high outliers
    if (score > 1000) {
        score = 1000 + Math.log10(score - 999) * 100;
    }
    
    return Math.max(0, score);
}
```

**YouTube Engagement Formula** (from your code):
```java
private double calculateYouTubeEngagement() {
    long likes = this.likeCount != null ? this.likeCount : 0;
    long comments = this.commentCount != null ? this.commentCount : 0;
    long views = this.viewCount != null ? this.viewCount : 0;
    
    if (views == 0) {
        // No views data, use absolute engagement
        return (likes * 1.5) + (comments * 3.0);
    }
    
    // Calculate engagement rate based on views
    double engagementRate = ((double) (likes + comments)) / views;
    double baseEngagement = (likes * 1.5) + (comments * 3.0);
    
    // Combine rate and absolute engagement
    return (engagementRate * views * 0.1) + baseEngagement;
}
```

## Data Conversion Layer

### Reddit to SocialPost Mapping
```java
// From RedditIngestionService.convertToSocialPost()
SocialPost socialPost = new SocialPost(
    Platform.REDDIT,
    redditPost.getId(),        // external_id
    redditPost.getTitle(),     // title  
    redditPost.getContent(),   // content (selftext)
    redditPost.getAuthor()     // author
);

// Reddit-specific fields
socialPost.setUpvotes(redditPost.getScore());
socialPost.setCommentCount(redditPost.getNumComments());
socialPost.setSubreddit(redditPost.getSubreddit());
socialPost.setUrl(redditPost.getUrl());
```

### YouTube to SocialPost Mapping  
```java
// From YouTubeIngestionService.convertToSocialPost()
SocialPost socialPost = new SocialPost(
    Platform.YOUTUBE,
    youtubeVideo.getId(),           // external_id
    youtubeVideo.getTitle(),        // title
    youtubeVideo.getDescription(),  // content
    youtubeVideo.getChannelTitle()  // author
);

// YouTube-specific fields
socialPost.setVideoId(youtubeVideo.getId());
socialPost.setLikeCount(youtubeVideo.getLikeCount());
socialPost.setViewCount(youtubeVideo.getViewCount());
socialPost.setCommentCount(youtubeVideo.getCommentCount());
socialPost.setUrl("https://www.youtube.com/watch?v=" + youtubeVideo.getId());
```

## Development Database Setup

### H2 Configuration (Current)
```properties
spring.datasource.url=jdbc:h2:mem:socialsentiment
spring.datasource.driver-class-name=org.h2.Driver
spring.jpa.hibernate.ddl-auto=create-drop
spring.h2.console.enabled=true
```

### Production PostgreSQL Migration (Ready)
```properties
# Replace H2 properties with:
spring.datasource.url=jdbc:postgresql://localhost:5432/socialsentiment
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=validate
```

## Data Validation Rules

### SocialPostDto Validation (From Your Code)
```java
@NotBlank(message = "External ID is required")
@Size(max = 255)
private String externalId;

@NotNull(message = "Platform is required")  
private Platform platform;

@NotBlank(message = "Title is required")
@Size(max = 500)
private String title;

@Size(max = 10000)
private String content;

@NotBlank(message = "Author is required")
@Size(max = 255)
private String author;

// Platform-specific validation
public boolean isValidForPlatform() {
    switch (platform) {
        case REDDIT:
            return content != null && !content.trim().isEmpty() && 
                   subreddit != null && !subreddit.trim().isEmpty();
        case YOUTUBE:
            return videoId != null && !videoId.trim().isEmpty();
        default:
            return false;
    }
}
```

## Extension Points

### Ready for Implementation
Your codebase is already structured for these enhancements:

1. **Sentiment Analysis** - `SentimentData` entity and DTOs exist
2. **Advanced Search** - `PostSearchCriteria` class fully implemented
3. **Analytics Reports** - `AnalyticsReport` DTO with all nested classes
4. **Redis Caching** - WebClient configuration supports it
5. **PostgreSQL** - Entity annotations are PostgreSQL-compatible

### Current Limitations
- **No sentiment processing service** - DTOs exist but no NLP integration
- **No advanced search endpoints** - criteria classes exist but no controller endpoints
- **No analytics generation** - report DTOs exist but no service implementation
- **No caching layer** - WebClient configured but no Redis integration

This data model successfully handles both Reddit and YouTube data with a clean, extensible design that's ready for your two-week enhancement sprint.